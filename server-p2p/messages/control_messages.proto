syntax = "proto3";


/**
 * This file contains all messages that are used in the melissa_p2p context.
 */

package melissa_p2p;

// Types

message StateId {
    uint32 t = 1;
    uint32 id = 2;
}

message Socket {
    string node_name = 1;
    uint32 port = 2;
}

message StateServer {
    repeated Socket head_ranks = 1;
}


// Messages

message Ping { }

message Pong { }

message Weight {
    StateId state_id = 1;
    uint32 runner_id = 2;
    double weight = 3;
}

// application ranks to job socket on weight server
message JobRequest {
    uint32 runner_id = 1;
}

message JobResponse {
    StateId job = 1;
    StateId parent = 2;
    uint32 nsteps = 3;
}

// headrank <-> headrank
message StateRequest {
    StateId state_id = 1;
}

message StateResponse {
    StateId state_id = 1;
    repeated string filenames = 2; // TODO: now we could simply use scp in a first test ;)
    // TODO: OR: Append another message containing the acutal data
    // TODO: check that we don't delete anything what is about to be sent to anothe runner atm
    // if state not there will just  send back emnpty file names list
}



// fti headranks to general purpose request socket
message RequestRunners {
    uint32 runner_id = 1;
    StateServer runner = 2;
}

message RespondRunners {
    repeated StateServer runners = 1;
} // replies empty list if there are no others. if no others: look on pfs...

// when runner fti heads have nothing to do they can do a prefetch
// the server will send back things that are worth prefetching
// Runner to server what might be useful to prefetch:
message PrefetchRequest { // the same as job request
    repeated StateId cached_states = 1;
    uint32 runner_id = 2;
}

message PrefetchResponse {
    StateId state_id = 1;
}


message DeleteRequest { // the same as job request
    repeated StateId cached_states = 1;
    uint32 runner_id = 2;
}

message DeleteResponse { // the same as job request
    repeated StateId cached_states = 1;
    uint32 runner_id = 2;
}



message RunnerCrashed {
    uint32 runner_id = 1;
}

message RunnerUp {
    uint32 runner_id = 1;
}

message StopStudy {
    enum ExitCode {
        SUCCESS = 0;
        FAILURE = 1;
    }

    ExitCode exit_code = 1;
}



// Wrapper message

message Message {
    oneof content {
        Ping ping = 1;
        Pong pong = 2;

        // Messages Server - Runner
        JobRequest job_request = 3;
        JobResponse job_response = 4;
        Weight weight = 5;
        PrefetchRequest prefetch_request = 6;
        PrefetchResponse prefetch_response = 7;

        // Messages Runner - Runner
        StateRequest state_request = 8;
        StateResponse state_response = 9;

        // Messages Server - Launcher
        RunnerCrashed runner_crashed = 10;
        RunnerUp runner_up = 11;
        StopStudy stop_study = 12;
    }
}

// MPI Messages within the API:
message DownloadState {
    StateId parent = 1;
    repeated StateServer runners = 2;
}
